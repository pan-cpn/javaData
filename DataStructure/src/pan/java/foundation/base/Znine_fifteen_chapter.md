##抽象类:abstract
* 抽象类可以有抽象方法也可以有非抽象方法
* 抽象类的子类继承抽象类是必须继承抽象类的所有抽象方法
* 抽象类中可以有非抽象属性，也可以有抽象属性
* 抽象类不是一个完善的类，其必须提高有子类继承，通过extends
* 抽象类中不能给使用final定义类和方法，也不能定义抽象类
* 抽象父类没有定义无参构造方法，而是提供了带参构造方法，那么子类就必须有带参构造方法，并且
* 通过super()调用抽象父类的带参构造方法
* 抽象类可以没有抽象方法


##包装类型的装箱和拆箱:
* 基本数据类型:byte  short  int  long  float  double  char  boolean
* 包装类:Byte  Short Boolean  Character  Integer Long Float Double 
* 


##接口:interface
* 接口和抽象一样必须有子类实例化，器自身不能够实例化
* 接口中不能够定义私有属性，器必须是public修饰符 default方法 和static方法
* 当子类不是抽象类时，就必须全部实现父类的抽象方法
* 接口使用implements关键字实现接口父类
* 接口中允许定义非抽象方法 需要使用static 子类在实现接口时，可以根据需要覆写普通方法
* 接口中定义普通方法的作用：简化子类的结构，子类能够根据需要覆写父类结构的方法
* 设计模式:工厂设计模式和代理设计模式

##接口和查偶像类都区别
* 接口:
* 可以定义全局常量，抽象方法，普通方法，静态方法
* 权限修饰符只能时public
* 接口不能继承抽象类，但是可以继承多个接口
* 实例化都是通过对象的向上转型实现
* 工厂设计模式和代理设计模式
* 一个类可以实现多个接口
* 抽象：
* 能够定义常量，变量，抽象和普通方法，构造方法
* 抽象类可以实现多个接口
* 一个类只能继承一个抽象类

##泛型
* ？ extends 类：泛型的上限
* ? super 类：泛型的下限
* 泛型方法：在方法的返回值前面定义泛型约束返回值

##设计模式
* 工厂设计模式
* 代理设计模式
* 单例设计模式:实现构造函数私有化，仅仅向外提供一个实例化对象
* 懒汉式单例设计模式：在使用时才进行实例化
* 饿汉式单例设计模式：在使用之前就先实例化
* 多例设计模式

##枚举ENUM
* 枚举的出现目的是替换多例模式
* 枚举的对象的名词都应该为大写
* 枚举所有对象的获取能够通过values()方法来实现

##内部类
* 内部类的嵌套，更好的访问外部类的私有属性
* 内部类的使用必须先实例化外部类，当使用的不适静态内部类时
* 不单止有内部类，接口也有内部接口
* 当为静态内部类时，可以实例化外部类然后直接使用内部类
* 当不为静态内部类时，需要实例化外部类再实例化内部类使用

##lambda表达式
* lamdba表达式的条件是，之哟与一个抽象方法的接口
* lamdba接口与普通接口的区别：
* 普通接口直接使用interfe定义
* lamdba接口需要使用@FunctionalInterface定义

##方法引用
* 引用静态方法：类名称::方法名
* 引用对象实力方法：实例化对象::普通方法名
* 引用特定类方法：特定类::普通方法
* 引用构造方法：类名称::new

##多线程
* 进程和线程的区别：
* 每一个程序的执行都是一个进程，每一个进程中又有多个线程
* 线程的销毁不会阻塞进程的执行，而进程一旦销毁，其对应的线程也会停止
* 使用多线程的两种方式:继承Thread和实现Runnable接口
* Runnable不能实现有返回值，而callable接口则能够实现带有返回值的线程
* 线程的运行状态:创建  就绪  运行 阻塞 销毁


##常用类库
* StringBuffer和StringBuilder
* CharSequence字符串操作接口，实现对字符串的字符的搜索，获取串的长度和截取字符串的长度
* AutoCloseable释放资源接口
* Runtime接口：获取系统的相关信息接口
* System类

##二叉树，红黑树

